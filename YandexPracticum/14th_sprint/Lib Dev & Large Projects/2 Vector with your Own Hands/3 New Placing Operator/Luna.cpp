/*
В C++ есть способ вручную сконструировать объект в ранее выделенной
сырой области памяти — размещающий оператор new. Его синтаксис:
new (адрес) Класс(параметры конструктора)
*/

/*
Он вызывает конструктор класса Класс по адресу адрес и передаёт
ему параметры конструктора. Адрес должен иметь выравнивание,
нужное для типа Класс. Более подробно о выравнивании объектов
в памяти вы узнаете в следующем спринте. Здесь затронем его на
минимально необходимом уровне. Размещающий оператор new
возвращает указатель типа Класс* на сконструированный объект.

Как только созданный так объект становится не нужен, его надо
удалить. Для этого вызывают деструктор:
*/

#include <iostream>
#include <memory>
#include <new>
#include <string>

using namespace std;



#include <iostream>
#include <string>

using namespace std;

class Cat {
public:
    Cat(string name, int age)
        : name_(move(name))
        , age_(age)  //
    {
        cout << "Hello from " << name_ << endl;
    }

    ~Cat() {
        cout << "Goodbye from "sv << name_ << endl;
    }

    void SayHello() const {
        cout << "Meow, my name is "sv << name_ << ". I'm "sv << age_ << " year old."sv << endl;
    }

private:
    string name_;
    int age_;
};



/*
В следующем примере в области стека выделяется массив размера,
достаточного для хранения объекта типа Cat. Затем размещающий
оператор new конструирует в этом массиве экземпляр класса Cat.
Перед выходом из main сконструированный вручную объект нужно
разрушить, явно вызвав его деструктор:
*/

int main() {
    alignas(Cat) char buf[sizeof(Cat)];
    Cat* cat = new (&buf[0]) Cat("Luna"s, 1);
    cat->SayHello();
    cat->~Cat();
}

/*
Спецификатор alignas сообщает компилятору, что массив buf
должен быть размещён в памяти с выравниванием, нужным типу
Cat. Иначе возможно неопределённое поведение.
*/
