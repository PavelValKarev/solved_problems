#include <iostream>
#include <array>

using namespace std;

/*
6 байт — уже достаточно круто. Но мы всё еще можем лучше.
Посчитаем, сколько битов занимает в памяти сами данные, без
битов и байтов выравнивания. 10 бит для num + 10 бит для
region + 4 бита на каждое из трёх полей с индексами символов.
Итого 32 бита. Но 32 бита — это ровно 4 байта. Вся структура
может уместиться в одну переменную типа uint32_t. Чтобы
явно сказать это компилятору, определим структуру так:
*/

const static int N = 12;
const std::array<char, N> Letters = {
    'A', 'B', 'E', 'K', 'M', 'H', 'O', 'P', 'C', 'T', 'Y', 'X' };

#pragma pack(push, 1)
struct Plate {
    uint32_t num : 10;
    uint32_t region : 10;
    uint32_t c1 : 4;
    uint32_t c2 : 4;
    uint32_t c3 : 4;
};
#pragma pack(pop)

//Макрос offsetof невозможно применить к полям базового класса. 
int main() {
    cout << "Sizeof = "s << sizeof(Plate) << endl;    
}

/*
Размер структуры сократился с 16 байт до 4, как и было
обещано в начале урока.
Последний трюк с переходом к uin32_t даёт выигрыш в данном
конкретном случае, но не всегда он обязателен для плотной упаковки.
*/

